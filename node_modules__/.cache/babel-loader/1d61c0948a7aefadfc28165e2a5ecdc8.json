{"ast":null,"code":"import { readString } from 'react-papaparse';\nimport KloudlessService from '../KloudlessService';\nconst FILE_SIZE_LIMIT = process.env.REACT_APP_FILE_SIZE_LIMIT || 10000000;\nconst COLUMN_COUNT_LIMIT = process.env.REACT_APP_FILE_COLUMN_COUNT_LIMIT || 50;\n\nconst readFromKloudlessToCsv = name => {\n  const content = KloudlessService.getContent(name);\n  console.log('Parsing input');\n  return readString(content, {\n    header: true\n  });\n};\n\nconst convertToDocumentObj = data => {\n  const columnHeaders = data.meta.fields;\n  const columnHeadersObject = columnHeaders.map((column, index) => {\n    return {\n      title: column,\n      orderPosition: index,\n      data: []\n    };\n  }).reduce((obj, item) => {\n    obj[item.title] = item;\n    return obj;\n  }, {}); // Clean up trailing invalid entries with only one empty entry (are generated by trailing new lines)\n\n  let index = data.data.length - 1;\n\n  while (index > 0 && Object.keys(data.data[index]).length === 1 && data.data[index][Object.keys(data.data[index])[0]] === '') {\n    index--;\n    data.data.pop();\n  }\n\n  data.data.forEach(row => {\n    Object.keys(columnHeadersObject).forEach(column => columnHeadersObject[column].data.push(row[column]));\n  });\n  return {\n    headers: columnHeaders,\n    data: columnHeadersObject\n  };\n};\n\nexport default {\n  readFromKloudlessToCsv,\n  convertToDocumentObj\n};","map":{"version":3,"sources":["C:/Users/ayesh/Desktop/TUM/semester 3/Final Presentation/dedas-frontend/src/service/ParsingService/CSVParserService.js"],"names":["readString","KloudlessService","FILE_SIZE_LIMIT","process","env","REACT_APP_FILE_SIZE_LIMIT","COLUMN_COUNT_LIMIT","REACT_APP_FILE_COLUMN_COUNT_LIMIT","readFromKloudlessToCsv","name","content","getContent","console","log","header","convertToDocumentObj","data","columnHeaders","meta","fields","columnHeadersObject","map","column","index","title","orderPosition","reduce","obj","item","length","Object","keys","pop","forEach","row","push","headers"],"mappings":"AAAA,SAASA,UAAT,QAA2B,iBAA3B;AACA,OAAOC,gBAAP,MAA6B,qBAA7B;AAEA,MAAMC,eAAe,GAAGC,OAAO,CAACC,GAAR,CAAYC,yBAAZ,IAAyC,QAAjE;AACA,MAAMC,kBAAkB,GAAGH,OAAO,CAACC,GAAR,CAAYG,iCAAZ,IAAiD,EAA5E;;AAGA,MAAMC,sBAAsB,GAAIC,IAAD,IAAU;AACrC,QAAMC,OAAO,GAAGT,gBAAgB,CAACU,UAAjB,CAA4BF,IAA5B,CAAhB;AACAG,EAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ;AACA,SAAOb,UAAU,CAACU,OAAD,EAAU;AAAEI,IAAAA,MAAM,EAAE;AAAV,GAAV,CAAjB;AACH,CAJD;;AAMA,MAAMC,oBAAoB,GAAIC,IAAD,IAAU;AACnC,QAAMC,aAAa,GAAGD,IAAI,CAACE,IAAL,CAAUC,MAAhC;AACA,QAAMC,mBAAmB,GAAGH,aAAa,CAACI,GAAd,CAAkB,CAACC,MAAD,EAASC,KAAT,KAAmB;AAC7D,WAAO;AAAEC,MAAAA,KAAK,EAAEF,MAAT;AAAiBG,MAAAA,aAAa,EAAEF,KAAhC;AAAuCP,MAAAA,IAAI,EAAE;AAA7C,KAAP;AACH,GAF2B,EAEzBU,MAFyB,CAElB,CAACC,GAAD,EAAMC,IAAN,KAAe;AACrBD,IAAAA,GAAG,CAACC,IAAI,CAACJ,KAAN,CAAH,GAAkBI,IAAlB;AACA,WAAOD,GAAP;AACH,GAL2B,EAKzB,EALyB,CAA5B,CAFmC,CASnC;;AACA,MAAIJ,KAAK,GAAGP,IAAI,CAACA,IAAL,CAAUa,MAAV,GAAmB,CAA/B;;AACA,SAAON,KAAK,GAAG,CAAR,IAAaO,MAAM,CAACC,IAAP,CAAYf,IAAI,CAACA,IAAL,CAAUO,KAAV,CAAZ,EAA8BM,MAA9B,KAAyC,CAAtD,IACPb,IAAI,CAACA,IAAL,CAAUO,KAAV,EAAiBO,MAAM,CAACC,IAAP,CAAYf,IAAI,CAACA,IAAL,CAAUO,KAAV,CAAZ,EAA8B,CAA9B,CAAjB,MAAuD,EADvD,EAC2D;AACvDA,IAAAA,KAAK;AACLP,IAAAA,IAAI,CAACA,IAAL,CAAUgB,GAAV;AACH;;AAEDhB,EAAAA,IAAI,CAACA,IAAL,CAAUiB,OAAV,CAAkBC,GAAG,IAAI;AACrBJ,IAAAA,MAAM,CAACC,IAAP,CAAYX,mBAAZ,EACKa,OADL,CACaX,MAAM,IAAIF,mBAAmB,CAACE,MAAD,CAAnB,CAA4BN,IAA5B,CAAiCmB,IAAjC,CAAsCD,GAAG,CAACZ,MAAD,CAAzC,CADvB;AAEH,GAHD;AAKA,SAAO;AAAEc,IAAAA,OAAO,EAAEnB,aAAX;AAA0BD,IAAAA,IAAI,EAAEI;AAAhC,GAAP;AACH,CAvBD;;AA0BA,eAAe;AACXZ,EAAAA,sBADW;AAEXO,EAAAA;AAFW,CAAf","sourcesContent":["import { readString } from 'react-papaparse';\r\nimport KloudlessService from '../KloudlessService';\r\n\r\nconst FILE_SIZE_LIMIT = process.env.REACT_APP_FILE_SIZE_LIMIT || 10000000;\r\nconst COLUMN_COUNT_LIMIT = process.env.REACT_APP_FILE_COLUMN_COUNT_LIMIT || 50;\r\n\r\n\r\nconst readFromKloudlessToCsv = (name) => {\r\n    const content = KloudlessService.getContent(name);\r\n    console.log('Parsing input');\r\n    return readString(content, { header: true });\r\n};\r\n\r\nconst convertToDocumentObj = (data) => {\r\n    const columnHeaders = data.meta.fields;\r\n    const columnHeadersObject = columnHeaders.map((column, index) => {\r\n        return { title: column, orderPosition: index, data: [] };\r\n    }).reduce((obj, item) => {\r\n        obj[item.title] = item;\r\n        return obj;\r\n    }, {});\r\n\r\n    // Clean up trailing invalid entries with only one empty entry (are generated by trailing new lines)\r\n    let index = data.data.length - 1;\r\n    while (index > 0 && Object.keys(data.data[index]).length === 1 &&\r\n    data.data[index][Object.keys(data.data[index])[0]] === '') {\r\n        index--;\r\n        data.data.pop();\r\n    }\r\n\r\n    data.data.forEach(row => {\r\n        Object.keys(columnHeadersObject)\r\n            .forEach(column => columnHeadersObject[column].data.push(row[column]));\r\n    });\r\n\r\n    return { headers: columnHeaders, data: columnHeadersObject };\r\n};\r\n\r\n\r\nexport default {\r\n    readFromKloudlessToCsv,\r\n    convertToDocumentObj\r\n};\r\n"]},"metadata":{},"sourceType":"module"}