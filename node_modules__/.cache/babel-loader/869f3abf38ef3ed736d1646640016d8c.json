{"ast":null,"code":"import AbstractAnonymizationService from '../AbstractAnonymizationService';\nimport AnonymizationAssignment from '../AnonymizationAssignment';\nimport Hashes from 'jshashes';\nimport bcrypt from 'bcryptjs';\nconst standardCipher = Hashes.SHA256.name;\n/**\r\n * Hashes a given column with optional salting\r\n */\n\nclass HashAnonymizationService extends AbstractAnonymizationService {}\n\nHashAnonymizationService.apply = (assignment, document) => {\n  const options = assignment.options; // Extract options from optionsMap\n\n  let cipher = options['cipher'] !== undefined ? options['cipher'] : standardCipher; // get Cipher implementation for name\n\n  cipher = HashAnonymizationService.getCipherByName(cipher); // Get salt string if there is one\n\n  let withSalt;\n\n  if (options['salt'] !== undefined) {\n    if (options['salt']) {\n      withSalt = options['withSalt'] !== undefined ? options['withSalt'] : bcrypt.genSaltSync(32);\n    } else {\n      withSalt = '';\n    }\n  } else {\n    withSalt = '';\n  } // get document column id on which we should work on\n\n\n  const columnId = AbstractAnonymizationService.getColumnIdByOrderId.call(HashAnonymizationService, assignment.columnOrderId, document); // Apply to document\n\n  document.data[columnId].data = document.data[columnId].data.map(cell => cipher.b64(cell + withSalt));\n};\n\nHashAnonymizationService.getCipherByName = name => {\n  if (name === Hashes.SHA1.name) {\n    return new Hashes.SHA1();\n  }\n\n  if (name === Hashes.SHA256.name) {\n    return new Hashes.SHA256();\n  }\n\n  throw 'Cipher ' + name + ' has not been defined';\n};\n\nHashAnonymizationService.getDescription = options => {\n  let cipher = options['cipher'] !== undefined ? options['cipher'] : standardCipher;\n  const text = 'hashed with cipher ' + cipher;\n\n  if (options['salt'] !== undefined && options['salt'] !== '' && options['salt']) {\n    return text + ' and salt';\n  } else {\n    return text;\n  }\n};\n\nHashAnonymizationService.getName = () => 'hash';\n\nexport default HashAnonymizationService;","map":{"version":3,"sources":["C:/Users/ayesh/Desktop/TUM/semester 3/Final Presentation/dedas-frontend/src/service/Anonymization/AnonymizationImplementation/HashAnonymizationService.js"],"names":["AbstractAnonymizationService","AnonymizationAssignment","Hashes","bcrypt","standardCipher","SHA256","name","HashAnonymizationService","apply","assignment","document","options","cipher","undefined","getCipherByName","withSalt","genSaltSync","columnId","getColumnIdByOrderId","columnOrderId","data","map","cell","b64","SHA1","getDescription","text","getName"],"mappings":"AAAA,OAAOA,4BAAP,MAAyC,iCAAzC;AACA,OAAOC,uBAAP,MAAoC,4BAApC;AAEA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEA,MAAMC,cAAc,GAAGF,MAAM,CAACG,MAAP,CAAcC,IAArC;AAEA;;;;AAGA,MAAMC,wBAAN,SAAuCP,4BAAvC,CAAoE;;AAA9DO,wB,CACKC,K,GAAQ,CAACC,UAAD,EAAsCC,QAAtC,KAAyD;AACpE,QAAMC,OAAO,GAAGF,UAAU,CAACE,OAA3B,CADoE,CAGpE;;AACA,MAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAP,KAAsBE,SAAtB,GACTF,OAAO,CAAC,QAAD,CADE,GACWP,cADxB,CAJoE,CAOpE;;AACAQ,EAAAA,MAAM,GAAGL,wBAAwB,CAACO,eAAzB,CAAyCF,MAAzC,CAAT,CARoE,CAUpE;;AACA,MAAIG,QAAJ;;AACA,MAAIJ,OAAO,CAAC,MAAD,CAAP,KAAoBE,SAAxB,EAAmC;AAC/B,QAAIF,OAAO,CAAC,MAAD,CAAX,EAAqB;AACjBI,MAAAA,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAP,KAAwBE,SAAxB,GACPF,OAAO,CAAC,UAAD,CADA,GACeR,MAAM,CAACa,WAAP,CAAmB,EAAnB,CAD1B;AAEH,KAHD,MAGO;AACHD,MAAAA,QAAQ,GAAG,EAAX;AACH;AACJ,GAPD,MAOO;AACHA,IAAAA,QAAQ,GAAG,EAAX;AACH,GArBmE,CAuBpE;;;AACA,QAAME,QAAQ,GAzBiBjB,4BAyBjB,CAASkB,oBAAT,MAzBhBX,wBAyBgB,EAA8BE,UAAU,CAACU,aAAzC,EAAwDT,QAAxD,CAAd,CAxBoE,CA0BpE;;AACAA,EAAAA,QAAQ,CAACU,IAAT,CAAcH,QAAd,EAAwBG,IAAxB,GAA+BV,QAAQ,CAACU,IAAT,CAAcH,QAAd,EAAwBG,IAAxB,CAA6BC,GAA7B,CAAiCC,IAAI,IAAIV,MAAM,CAACW,GAAP,CAAWD,IAAI,GAAGP,QAAlB,CAAzC,CAA/B;AACH,C;;AA7BCR,wB,CA+BKO,e,GAAmBR,IAAD,IAAkB;AACvC,MAAIA,IAAI,KAAKJ,MAAM,CAACsB,IAAP,CAAYlB,IAAzB,EAA+B;AAC3B,WAAO,IAAIJ,MAAM,CAACsB,IAAX,EAAP;AACH;;AAED,MAAIlB,IAAI,KAAKJ,MAAM,CAACG,MAAP,CAAcC,IAA3B,EAAiC;AAC7B,WAAO,IAAIJ,MAAM,CAACG,MAAX,EAAP;AACH;;AAED,QAAM,YAAYC,IAAZ,GAAmB,uBAAzB;AACH,C;;AAzCCC,wB,CA2CKkB,c,GAAkBd,OAAD,IAAqB;AACzC,MAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAP,KAAsBE,SAAtB,GACTF,OAAO,CAAC,QAAD,CADE,GACWP,cADxB;AAGA,QAAMsB,IAAI,GAAG,wBAAwBd,MAArC;;AAEA,MAAID,OAAO,CAAC,MAAD,CAAP,KAAoBE,SAApB,IACAF,OAAO,CAAC,MAAD,CAAP,KAAoB,EADpB,IAEAA,OAAO,CAAC,MAAD,CAFX,EAEqB;AACjB,WAAOe,IAAI,GAAG,WAAd;AACH,GAJD,MAIO;AACH,WAAOA,IAAP;AACH;AACJ,C;;AAxDCnB,wB,CA0DKoB,O,GAAU,MAAc,M;;AAGnC,eAAepB,wBAAf","sourcesContent":["import AbstractAnonymizationService from '../AbstractAnonymizationService';\r\nimport AnonymizationAssignment from '../AnonymizationAssignment';\r\n\r\nimport Hashes from 'jshashes';\r\nimport bcrypt from 'bcryptjs';\r\n\r\nconst standardCipher = Hashes.SHA256.name;\r\n\r\n/**\r\n * Hashes a given column with optional salting\r\n */\r\nclass HashAnonymizationService extends AbstractAnonymizationService {\r\n    static apply = (assignment: AnonymizationAssignment, document): void => {\r\n        const options = assignment.options;\r\n\r\n        // Extract options from optionsMap\r\n        let cipher = options['cipher'] !== undefined ?\r\n            options['cipher'] : standardCipher;\r\n\r\n        // get Cipher implementation for name\r\n        cipher = HashAnonymizationService.getCipherByName(cipher);\r\n\r\n        // Get salt string if there is one\r\n        let withSalt;\r\n        if (options['salt'] !== undefined) {\r\n            if (options['salt']) {\r\n                withSalt = options['withSalt'] !== undefined ?\r\n                    options['withSalt'] : bcrypt.genSaltSync(32);\r\n            } else {\r\n                withSalt = '';\r\n            }\r\n        } else {\r\n            withSalt = '';\r\n        }\r\n\r\n        // get document column id on which we should work on\r\n        const columnId = super.getColumnIdByOrderId(assignment.columnOrderId, document);\r\n\r\n        // Apply to document\r\n        document.data[columnId].data = document.data[columnId].data.map(cell => cipher.b64(cell + withSalt));\r\n    };\r\n\r\n    static getCipherByName = (name: String) => {\r\n        if (name === Hashes.SHA1.name) {\r\n            return new Hashes.SHA1();\r\n        }\r\n\r\n        if (name === Hashes.SHA256.name) {\r\n            return new Hashes.SHA256();\r\n        }\r\n\r\n        throw 'Cipher ' + name + ' has not been defined';\r\n    };\r\n\r\n    static getDescription = (options): String => {\r\n        let cipher = options['cipher'] !== undefined ?\r\n            options['cipher'] : standardCipher;\r\n\r\n        const text = 'hashed with cipher ' + cipher;\r\n\r\n        if (options['salt'] !== undefined &&\r\n            options['salt'] !== '' &&\r\n            options['salt']) {\r\n            return text + ' and salt';\r\n        } else {\r\n            return text;\r\n        }\r\n    };\r\n\r\n    static getName = (): String => 'hash';\r\n}\r\n\r\nexport default HashAnonymizationService;\r\n"]},"metadata":{},"sourceType":"module"}