"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.last-index-of");

require("core-js/modules/es.array.map");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.link");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable camelcase, no-underscore-dangle, func-names,
                  prefer-destructuring */

/* global EXPLORER_URL */
var _css = document.createElement("style");

_css.innerHTML = "iframe.kloudless-modal, iframe.kloudless-modal-dropzone {   display: block;   box-sizing: border-box;   position: fixed;   top: 50%;   left: 50%;   width: 700px;   height: 515px;   margin-top: -250px;   margin-left: -350px;   border: 0;   border-radius: 4px;   box-shadow: 0 14px 20px rgba(0,0,0,0.08);   transition: all 0;   -webkit-transition: all 0;   z-index: 999; } @media only screen and (max-width: 699px), only screen and (max-device-width: 699px) {   iframe.kloudless-modal,   iframe.kloudless-modal-dropzone {     width: 100%;     height: 100%;     position: fixed !important;     margin: 0;     top: 0;     left: 0;   }   iframe.kloudless-modal html,   iframe.kloudless-modal-dropzone html,   iframe.kloudless-modal body,   iframe.kloudless-modal-dropzone body {     overflow: hidden;   } } iframe.kloudless-modal-dropzone {   position: relative;   top: 0;   left: 0;   margin-top: 0;   margin-left: 0; } .backdrop_div {   position: fixed;   margin: 0;   top: 0;   left: 0;   padding: 0;   width: 100%;   height: 100%;   display: none;   background-color: #000;   z-index: 998;   opacity: 0.6; } .kloudless_dropzone_container {   display: -ms-flexbox;   display: flex;   -ms-flex-align: center;       align-items: center;   -ms-flex-pack: center;       justify-content: center;   box-sizing: border-box;   position: relative;   cursor: pointer;   background-color: #f5f6f7;   color: #474747;   border-style: dashed;   border-width: 1px;   width: 600px;   height: 100px;   border-radius: 4px;   box-shadow: 0 14px 20px rgba(0,0,0,0.08); } @media only screen and (max-width: 699px), only screen and (max-device-width: 699px) {   .kloudless_dropzone_container {     width: 100% !important;     height: 100% !important;     position: fixed !important;     margin: 0;     top: 0;     left: 0;   }   .kloudless_dropzone_container html,   .kloudless_dropzone_container body {     overflow: hidden;   } } .kloudless_dropzone_container > span {   position: absolute;   padding: 0px 5px; } "
document.head.appendChild(_css)
/**
 * Define the module and the interface with which developers interact.
 */

/**
 * Helper methods and objects
 */
// Element class helper methods

function addClass(el, newClassName) {
  el.classList.add(newClassName);
}

function removeClass(el, removeClassName) {
  el.classList.remove(removeClassName);
}

function isMobile() {
  return !!navigator.userAgent.match(/(iPad|iPhone|iPod|android|Android)/g);
}

var FX = {
  easing: {
    linear: function linear(progress) {
      return progress;
    },
    quadratic: function quadratic(progress) {
      return Math.pow(progress, 2);
    }
  },
  animate: function animate(options) {
    var start = new Date();
    var id = setInterval(function () {
      var timePassed = new Date() - start;
      var progress = timePassed / options.duration;

      if (progress > 1) {
        progress = 1;
      }

      options.progress = progress;
      var delta = options.delta(progress);
      options.step(delta);

      if (progress === 1) {
        clearInterval(id);

        if (typeof options.complete !== 'undefined') {
          options.complete();
        }
      }
    }, options.delay || 10);
  },
  fadeOut: function fadeOut(element, options) {
    var to = 1;
    this.animate({
      duration: options.duration,
      delta: function delta(progress) {
        return FX.easing.quadratic(progress);
      },
      complete: options.complete,
      step: function step(delta) {
        element.style.opacity = to - delta;
      }
    });
  },
  fadeIn: function fadeIn(element, options) {
    var to = 0;
    this.animate({
      duration: options.duration,
      delta: function delta(progress) {
        progress = this.progress; // eslint-disable-line

        return FX.easing.quadratic(progress);
      },
      complete: options.complete,
      step: function step(delta) {
        element.style.opacity = to + delta;
      }
    });
  }
};
/*
 * Track all variables
 *
 * fileExplorer object, frames, explorers.
 */

/**
 * Global Options
 */

var globalOptions = {
  explorerUrl: '',
  explorerOrigin: '' // computed options

};
var fileExplorer = {
  _frames: {},
  _explorers: {},
  _queuedAction: {}
}; // Keep track of all frames and explorers

var frames = fileExplorer._frames;
var explorers = fileExplorer._explorers;
var queuedAction = fileExplorer._queuedAction;
var backdropDiv = null;
var bodyOverflow = null;
/**
 * setGlobalOptions()
 */

fileExplorer.setGlobalOptions = function (_ref) {
  var explorerUrl = _ref.explorerUrl;
  var oldExplorerUrl = globalOptions.explorerUrl;
  var pathParts = explorerUrl.split('://', 2);
  var explorerOrigin = "".concat(pathParts[0], "://").concat(pathParts[1].split('/')[0]); // update existing frames when changing explorerUrl

  Object.keys(frames).forEach(function (key) {
    var frame = frames[key];
    var src = frame.getAttribute('src');
    frame.setAttribute('src', src.replace(oldExplorerUrl, "".concat(explorerUrl)));
  });
  globalOptions.explorerUrl = explorerUrl;
  globalOptions.explorerOrigin = explorerOrigin;
};
/**
 * getGlobalOptions()
 */


fileExplorer.getGlobalOptions = function () {
  return _objectSpread({}, globalOptions);
};

var explorerUrl = "https://static-cdn.kloudless.com/p/platform/explorer/explorer.html";

if (explorerUrl.indexOf('://') === -1) {
  var location = window.location;
  explorerUrl = "".concat(location.protocol, "//").concat(location.host).concat(explorerUrl);
}

fileExplorer.setGlobalOptions({
  explorerUrl: explorerUrl
});
/**
 * Set up messaging, frames, explorers.
 */

(function () {
  function parseJsonString(data) {
    try {
      return JSON.parse(data);
    } catch (err) {
      return null;
    }
  }
  /**
   * Listen for incoming postMessages relating to widget events.
   */


  window.addEventListener('message', function (message) {
    if (message.origin !== globalOptions.explorerOrigin) {
      return;
    }

    var contents = parseJsonString(message.data);

    if (contents === null) {
      return;
    } // Grab the explorer id


    var exp_id = contents.exp_id; // Listen for file explorer events.
    // postMessage based on explorer id

    var explorer = fileExplorer._explorers[exp_id];

    if (explorer) {
      explorer._fire(contents.action, contents.data);
    }
  });
})(); // Initialize an iframe.
// eslint-disable-next-line


var initialize_frame = function initialize_frame(options, elementId) {
  var exp_id = Math.floor(Math.random() * Math.pow(10, 12));
  var frame = document.createElement('iframe');

  if (isMobile()) {
    frame.setAttribute('scrolling', 'no');
  }

  frame.setAttribute('class', 'kloudless-modal');
  var queryStrings = ["app_id=".concat(options.app_id), "exp_id=".concat(exp_id), "flavor=".concat(options.flavor), "origin=".concat(encodeURIComponent("".concat(window.location.protocol, "//").concat(window.location.host))), "custom_css=".concat(encodeURIComponent(options.custom_css)), "multiselect=".concat(options.multiselect), "link=".concat(options.link), "computer=".concat(options.computer), "copy_to_upload_location=".concat(options.copy_to_upload_location), "upload_location_uri=".concat(options.upload_location_uri), "services=".concat(JSON.stringify(options.services)), "persist=".concat(JSON.stringify(options.persist)), "account_key=".concat(options.account_key), "create_folder=".concat(options.create_folder), "types=".concat(JSON.stringify(options.types))];
  frame.setAttribute('src', "".concat(globalOptions.explorerUrl, "?").concat(queryStrings.join('&')));
  frame.style.display = 'none';
  frames[exp_id] = frame;
  var body = document.getElementsByTagName('body')[0];

  if (elementId) {
    var el = document.getElementById(elementId);
    el.appendChild(frame);
  } else {
    body.appendChild(frame);
  }

  if (!backdropDiv) {
    var div = document.createElement('div');
    backdropDiv = body.appendChild(div);
    addClass(backdropDiv, 'backdrop_div');
  }

  return exp_id;
}; // Common file widget methods.


fileExplorer._fileWidget = function (options) {
  this._setOptions(options);

  this.handlers = {};
  this.defaultHandlers = {};
  this.elements = [];
  this.clickHandlers = [];
}; // Set options.


fileExplorer._fileWidget.prototype._setOptions = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  /*
     * This method has historically set data on `this`, and passed it in
     * via the querystring. Since this isn't scalable, and pollutes the
     * self/this namespace, we should store it namespaced under an `options`
     * object for future options, and pass it in via the DATA call for vars
     * not essential to instantiation.
     */
  if (!options.app_id) {
    throw new Error('You need to specify an app ID.');
  }

  this.options = options;
  this.app_id = options.app_id;
  this.exp_id = options.exp_id;
  this.custom_css = options.custom_css ? options.custom_css : false; // These don't need to be passed for query variables

  this.elementId = options.elementId;
  this.flavor = options.flavor === undefined ? 'chooser' : options.flavor;
  this.multiselect = options.multiselect === undefined ? false : options.multiselect;
  this.link = options.link === undefined ? true : options.link;
  this.computer = options.computer === undefined ? false : options.computer;
  this.copy_to_upload_location = options.copy_to_upload_location === undefined ? null : options.copy_to_upload_location;
  this.upload_location_uri = window.encodeURIComponent(options.upload_location_uri || '');
  this.create_folder = options.create_folder === undefined ? true : options.create_folder;
  this.account_key = options.account_key === undefined ? false : options.account_key;
  this.persist = options.persist === undefined ? 'local' : options.persist;
  this.display_backdrop = options.display_backdrop === undefined ? false : options.display_backdrop;
  this.services = options.services || null;
  this.files = options.files || [];
  this.types = options.types || [];

  if (!(this.files instanceof Array)) {
    this.files = [];
  }

  if (!(this.types instanceof Array)) {
    this.types = [this.types];
  }

  this.types = this.types.map(function (type) {
    return type.substr(type.lastIndexOf('.') + 1);
  }); // Backwards compatibility for direct_link

  if (!this.options.link_options) {
    this.options.link_options = {};
  }

  if (options.direct_link !== undefined && this.options.link_options.direct === undefined) {
    this.options.link_options.direct = options.direct_link;
  }

  return this;
}; // Define handlers. New handlers will override pre-existing ones.


fileExplorer._fileWidget.prototype.on = function (event, handler) {
  if (this.handlers[event] === undefined) {
    this.handlers[event] = [];
  }

  this.handlers[event].push(handler);
  return this;
}; // Fire an event handler. Called by the message listeners.


fileExplorer._fileWidget.prototype._fire = function (event, data) {
  var _this = this;

  if (['success', 'cancel'].indexOf(event) !== -1) {
    this.close();
  }

  var defaultHandler = this.defaultHandlers[event];

  if (defaultHandler) {
    window.setTimeout(function () {
      defaultHandler.call(_this, data);
    }, 0);
  }

  if (this.handlers[event] !== undefined) {
    for (var i = 0; i < this.handlers[event].length; i += 1) {
      (function (handler) {
        var _this2 = this;

        window.setTimeout(function () {
          handler.call(_this2, data);
        }, 0);
      })(this.handlers[event][i]);
    }
  }

  if ('raw' in this.handlers) {
    // `raw` event is used by the react/vue binding
    window.setTimeout(function () {
      return _this.handlers.raw[0]({
        action: event,
        data: data
      });
    }, 0);
  }

  return this;
};
/*
   * Explorer
   */


fileExplorer.explorer = function (options) {
  // first step is to return a new object
  var exp = new fileExplorer._explorer(options);
  exp.on('load', function () {
    // TODO: INIT post message with all config variables
    exp.message('INIT', {
      options: options
    });
    exp.loaded = true;

    if (queuedAction[exp.exp_id]) {
      var _queuedAction$exp$exp = queuedAction[exp.exp_id],
          method = _queuedAction$exp$exp.method,
          args = _queuedAction$exp$exp.args;
      delete queuedAction[exp.exp_id];
      method.apply(exp, args);
    }
  });
  var id = initialize_frame({
    app_id: exp.app_id,
    exp_id: exp.exp_id,
    flavor: exp.flavor,
    custom_css: exp.custom_css,
    multiselect: exp.multiselect,
    link: exp.link,
    computer: exp.computer,
    copy_to_upload_location: exp.copy_to_upload_location,
    upload_location_uri: exp.upload_location_uri,
    account_key: exp.account_key,
    services: exp.services,
    persist: exp.persist,
    types: exp.types,
    create_folder: exp.create_folder
  }, exp.elementId);
  exp.exp_id = id;

  exp.defaultHandlers.close = function () {
    var frame = frames[exp.exp_id];

    if (frame) {
      FX.fadeOut(frame, {
        duration: 200,
        complete: function complete() {
          frame.style.display = 'none';
        }
      });
    }
  };

  explorers[exp.exp_id] = exp;
  return exp;
}; // Construct the explorer.


fileExplorer._explorer = function (options) {
  fileExplorer._fileWidget.call(this, options);
};

fileExplorer._explorer.prototype = Object.create(fileExplorer._fileWidget.prototype);
fileExplorer._explorer.prototype.constructor = fileExplorer._explorer;
Object.defineProperty(fileExplorer._explorer.prototype, 'constructor', {
  enumerable: false,
  value: fileExplorer._explorer
}); // Send a message to the explorer frame

fileExplorer._explorer.prototype.message = function (action, data) {
  var frame = frames[this.exp_id];

  if (frame) {
    frame.contentWindow.postMessage(JSON.stringify({
      action: action,
      data: data
    }), globalOptions.explorerUrl);
  } // console.log('Explorer message sent.');

}; // Update the explorer config


fileExplorer._explorer.prototype.update = function (opts) {
  this.message('DATA', {
    options: opts
  }); // Also update this.options

  this.options = _objectSpread({}, this.options, opts);
}; // Open the chooser


fileExplorer._explorer.prototype.choose = function () {
  if (!this.loaded) {
    queuedAction[this.exp_id] = {
      method: this.choose
    };
    return;
  }

  this._open({
    flavor: 'chooser'
  });

  return this; // eslint-disable-line
}; // Open the saver


fileExplorer._explorer.prototype.save = function (files) {
  if (!this.loaded) {
    queuedAction[this.exp_id] = {
      method: this.save,
      args: [files]
    };
    return;
  }

  if (!(files instanceof Array)) {
    files = []; // eslint-disable-line
  }

  files = this.files.concat(files); // eslint-disable-line
  // Need to have at least 1 file to save

  if (files.length < 1) {
    console.log('ERROR: No files to save');
    return;
  } // Send over files inside the options or those sent with save()


  this._open({
    flavor: 'saver',
    files: files
  });

  return this; // eslint-disable-line
};

fileExplorer._explorer.prototype._open = function (data) {
  var body = document.getElementsByTagName('body')[0];
  data.options = this.options;
  this.message('DATA', data); // Store the last scrollTop value so we can reset it when the explorer
  // closes

  fileExplorer._fileWidget.lastScrollTop = body.scrollTop; // Then scroll to the top of the file explorer after it's set
  // if the user is mobile

  if (isMobile()) {
    body.scrollTop = 0;
  }

  frames[this.exp_id].style.display = 'block';
  frames[this.exp_id].style.opacity = 0;
  addClass(body, 'kfe-active');

  if (data.flavor !== 'dropzone') {
    FX.fadeIn(frames[this.exp_id], {
      duration: 200
    });
  }

  if (this.display_backdrop) {
    backdropDiv.style.display = 'block';
    bodyOverflow = body.style.overflow;
    body.style.overflow = 'hidden';
  }

  this._fire('open');

  return this;
}; // Close the explorer


fileExplorer._explorer.prototype.close = function () {
  var body = document.getElementsByTagName('body')[0];

  if (!this.loaded) {
    queuedAction[this.exp_id] = {
      method: this.close
    };
    return;
  }

  this.message('CLOSING');
  removeClass(body, 'kfe-active');
  var lastScrollTop = fileExplorer._fileWidget.lastScrollTop;

  if (typeof lastScrollTop !== 'undefined') {
    if (isMobile()) {
      body.scrollTop = lastScrollTop;
    }
  }

  if (this.display_backdrop) {
    backdropDiv.style.display = 'none';
    body.style.overflow = bodyOverflow;
  }

  this._fire('close');
};

fileExplorer._explorer.prototype._bindElement = function (element, clickHandler) {
  var _this$elements;

  var elements = [];

  if (element instanceof Array) {
    elements = element;
  } else if (window.jQuery !== undefined && element instanceof window.jQuery) {
    elements = element.toArray();
  } else {
    elements = [element];
  }

  elements.forEach(function (e) {
    return e.addEventListener('click', clickHandler);
  });

  (_this$elements = this.elements).push.apply(_this$elements, _toConsumableArray(elements));

  this.clickHandlers.push(clickHandler);
  return this;
}; // Bind the file exploring dialogue to an element.


fileExplorer._explorer.prototype.choosify = function (element) {
  var clickHandler = this.choose.bind(this);
  return this._bindElement(element, clickHandler);
}; // Bind the file exploring dialogue to an element.


fileExplorer._explorer.prototype.savify = function (element, files) {
  var clickHandler = this.save.bind(this, files);
  return this._bindElement(element, clickHandler);
};

fileExplorer._explorer.prototype.destroy = function () {
  var _this3 = this;

  var frame = frames[this.exp_id];
  delete frames[this.exp_id];
  delete explorers[this.exp_id];
  this.close();
  this.elements.forEach(function (e) {
    _this3.clickHandlers.forEach(function (handler) {
      e.removeEventListener('click', handler);
    });
  });
  frame.parentNode.removeChild(frame);
  delete queuedAction[this.exp_id];
};
/**
 * Dropzone
 */


fileExplorer.dropzone = function (options) {
  return new fileExplorer._dropzone(_objectSpread({}, options));
};

fileExplorer._dropzone = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  this.isDestroyed = false;
  this.elementId = options.elementId;
  delete options.elementId;

  if (!this.elementId) {
    throw new Error('Please specify the elementId for the dropzone to be bound to.');
  }

  this.dropExplorer = fileExplorer.explorer({
    app_id: options.app_id,
    flavor: 'dropzone',
    multiselect: options.multiselect,
    elementId: this.elementId
  });
  this.clickExplorer = fileExplorer.explorer(options);
  this.dropExplorerFrame = frames[this.dropExplorer.exp_id];
  this.clickExplorerFrame = frames[this.clickExplorer.exp_id];

  this._configureFrame();
};

fileExplorer._dropzone.prototype._configureFrame = function () {
  var _this4 = this;

  /**
   * The drop explorer is always opened. But set its iframe opacity to 0 before
   * users dropping files or after uploading process succeed/canceled.
   */
  var element = document.getElementById(this.elementId);
  var frame = this.dropExplorerFrame;
  var dropExp = this.dropExplorer;
  var clickExp = this.clickExplorer; // Cannot set opacity to 0 because that makes the iframe not clickable in
  // Chrome.

  var transparentOpacity = '0.000000001';
  element.classList.add('kloudless_dropzone_container');

  if (element.getElementsByTagName('span').length === 0) {
    // Add span only if not exists
    var content = document.createElement('span');
    content.innerHTML = 'Drag and drop files here, or click to open the File Explorer';
    element.appendChild(content);
  } // Override default close handler so frame isn't set to 'display: none'


  dropExp.defaultHandlers.close = function () {
    frame.style.opacity = transparentOpacity;
  };

  frame.style.display = 'block';
  frame.style.opacity = transparentOpacity;
  frame.style.height = '100%';
  frame.style.width = '100%';
  frame.setAttribute('class', 'kloudless-modal-dropzone');

  frame.onload = function () {
    if (frame._hasLoadedOnce) {
      // prevent `setExplorerUrl` from duplicate event listener registration
      return;
    }

    dropExp.on('dropzoneClicked', function () {
      clickExp._open({
        flavor: 'chooser'
      });
    });
    dropExp.on('drop', function () {
      element.style.width = '700px';
      element.style.height = '515px';
      element.style['border-style'] = 'none';
      frame.style.opacity = '1';
    }); // Since the drop event will override CSS properties, we need
    // to retain original values so we can restore them on close.

    var style = window.getComputedStyle(element);
    var height = style.height,
        width = style.width,
        borderStyle = style['border-style'];
    dropExp.on('close', function () {
      element.style.height = height;
      element.style.width = width;
      element.style['border-style'] = borderStyle;

      if (!_this4.isDestroyed) {
        dropExp._open({
          flavor: 'dropzone'
        });
      }

      frame.style.opacity = transparentOpacity;
    });
    frame._hasLoadedOnce = true;
  };

  return frame;
};

fileExplorer._dropzone.prototype.on = function (event, handler) {
  this.dropExplorer.on(event, handler);
  this.clickExplorer.on(event, handler);
  return this;
};

fileExplorer._dropzone.prototype.close = function () {
  this.dropExplorer.close();
  this.clickExplorer.close();
};

fileExplorer._dropzone.prototype.update = function (opts) {
  this.dropExplorer.update(opts);
  this.clickExplorer.update(opts);
};

fileExplorer._dropzone.prototype.destroy = function () {
  this.isDestroyed = true;
  this.dropExplorer.destroy();
  this.clickExplorer.destroy();
  this.dropExplorer = null;
  this.clickExplorer = null;
};

var _default = fileExplorer;
exports.default = _default;